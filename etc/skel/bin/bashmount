#!/bin/bash

#=============================================================================#
#        FILE: bashmount                                                      #
#     VERSION: 1.3.1                                                          #
# DESCRIPTION: a menu-driven bash script that uses udisks to manage removable #
#              and optical media, allowing you to mount/unmount/eject without #
#              dependencies on any GUI or desktop environment, and without    #
#              having to type long commands.                                  #
#     LICENSE: GPL2                                                           #
#      AUTHOR: Jamie Nguyen                                                   #
#=============================================================================#

# Copyright (C) 2011 Jamie Nguyen
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License v2 as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA


declare -r VERSION="1.3.1"

#-------------------------------------#
#           CONFIGURATION             #
#-------------------------------------#
# {{{

# set some defaults for the configuration variables. see bashmount.conf for
# more information.
declare udisks="/usr/bin/udisks"
declare optical_devices="-E ^/dev/sr[0-9]+"
declare removable_devices="-E ^/dev/sd[b-z][0-9]*|^/dev/mmcblk[0-9]+p*[0-9]*"
declare mount_options="--mount-options nosuid,noexec,noatime"

declare -i show_removable=1
declare -i show_optical=1
declare -i show_commands=1
declare -i colourize=1
declare -i show_internal=0
declare -i show_removable_device_filename=1
declare -i show_optical_device_filename=1
declare -i fancy_sort=0
declare -i custom1_show=0
declare -i custom2_show=0
declare -i custom3_show=0
declare -i custom4_show=0
declare -i custom5_show=0
declare -i custom6_show=0

filemanager() {
	/usr/bin/Thunar "${1}" & >/dev/null 2>&1
}

declare CONFIGFILE

if [[ -n "${XDG_CONFIG_HOME}" ]]; then
	CONFIGFILE="${XDG_CONFIG_HOME}/bashmount/config"
else
	CONFIGFILE="${HOME}/.config/bashmount/config"
fi

if [[ ! -f "${CONFIGFILE}" ]]; then
	CONFIGFILE="/etc/bashmount.conf"
fi

if [[ -f "${CONFIGFILE}" ]]; then
	. "${CONFIGFILE}"
	if [[ $? -ne 0 ]]; then
		printf '\n%s\n' "bashmount: error: failed to source configuration file"
		exit 1
	fi
fi

if [[ ! -f "${udisks}" ]]; then
	printf '%s\n' "bashmount: error: udisks command not found"
	exit 1
fi
# }}}

#-------------------------------------#
#         GENERAL FUNCTIONS           #
#-------------------------------------#
# {{{

unset ALL_OFF BOLD BLUE GREEN RED
if [[ "${colourize}" -eq 1 ]]; then
	if tput setaf 0 &>/dev/null; then
		ALL_OFF="$(tput sgr0)"
		BOLD="$(tput bold)"
		BLUE="${BOLD}$(tput setaf 4)"
		GREEN="${BOLD}$(tput setaf 2)"
		RED="${BOLD}$(tput setaf 1)"
	else
		ALL_OFF="\e[1;0m"
    	BOLD="\e[1;1m"
    	BLUE="${BOLD}\e[1;34m"
    	GREEN="${BOLD}\e[1;32m"
    	RED="${BOLD}\e[1;31m"
	fi
	readonly ALL_OFF BOLD BLUE GREEN RED
fi

msg() {
	printf '%s\n' "${GREEN}==>${ALL_OFF}${BOLD} ${@}${ALL_OFF}" >&2
}
error() {
	printf '%s\n' "${RED}==>${ALL_OFF}${BOLD} ERROR: ${@}${ALL_OFF}" >&2
}
clear_screen() {
	clear;printf '%s\n\n' "bashmount ${VERSION}"
}
print_commands() {
	print_separator_commands
	printf '%s' "${BLUE}e${ALL_OFF}: eject   ${BLUE}i${ALL_OFF}: info   "
	printf '%s' "${BLUE}m${ALL_OFF}: mount   ${BLUE}o${ALL_OFF}: open   "
	printf '%s' "${BLUE}u${ALL_OFF}: unmount"
	printf '\n\n'
	printf '%s' "${BLUE}a${ALL_OFF}: unmount all   ${BLUE}r${ALL_OFF}: refresh   "
	printf '%s' "${BLUE}q${ALL_OFF}: quit   ${BLUE}?${ALL_OFF}: help"
	printf '\n\n'
}
print_submenu_commands() {
	print_separator_commands
	printf '%s' "${BLUE}e${ALL_OFF}: eject   ${BLUE}i${ALL_OFF}: info   "
	
	if [[ "${info_mounted}" = "0" ]]; then
		printf '%s' "${BLUE}m${ALL_OFF}: mount   "
	fi
	
	printf '%s' "${BLUE}o${ALL_OFF}: open   "
	
	if [[ "${info_mounted}" = "1" ]]; then
		printf '%s' "${BLUE}u${ALL_OFF}: unmount"
	fi
	
	printf '\n\n'
	printf '%s' "${BLUE}b${ALL_OFF}: back   ${BLUE}r${ALL_OFF}: refresh   "
	printf '%s' "${BLUE}q${ALL_OFF}: quit   ${BLUE}?${ALL_OFF}: help"
	printf '\n'

	if [[ "${custom1_show}" -eq 1 ]] \
		|| [[ "${custom2_show}" -eq 1 ]] \
		|| [[ "${custom3_show}" -eq 1 ]]; then
		printf '\n'
	fi

	if [[ "${custom1_show}" -eq 1 ]] && [[ -n "${custom1_desc}" ]]; then
		printf '%s' "${BLUE}1${ALL_OFF}: ${custom1_desc}   "
	fi

	if [[ "${custom2_show}" -eq 1 ]] && [[ -n "${custom2_desc}" ]]; then
		printf '%s' "${BLUE}2${ALL_OFF}: ${custom2_desc}   "
	fi

	if [[ "${custom3_show}" -eq 1 ]] && [[ -n "${custom3_desc}" ]]; then
		printf '%s' "${BLUE}3${ALL_OFF}: ${custom3_desc}   "
	fi

	if [[ "${custom1_show}" -eq 1 ]] \
		|| [[ "${custom2_show}" -eq 1 ]] \
		|| [[ "${custom3_show}" -eq 1 ]]; then
		printf '\n'
	fi

	if [[ "${custom4_show}" -eq 1 ]] \
		|| [[ "${custom5_show}" -eq 1 ]] \
		|| [[ "${custom6_show}" -eq 1 ]]; then
		printf '\n'
	fi

	if [[ "${custom4_show}" -eq 1 ]] && [[ -n "${custom4_desc}" ]]; then
		printf '%s' "${BLUE}4${ALL_OFF}: ${custom4_desc}   "
	fi

	if [[ "${custom5_show}" -eq 1 ]] && [[ -n "${custom5_desc}" ]]; then
		printf '%s' "${BLUE}5${ALL_OFF}: ${custom5_desc}   "
	fi

	if [[ "${custom6_show}" -eq 1 ]] && [[ -n "${custom6_desc}" ]]; then
		printf '%s' "${BLUE}6${ALL_OFF}: ${custom6_desc}   "
	fi

	if [[ "${custom4_show}" -eq 1 ]] \
		|| [[ "${custom5_show}" -eq 1 ]] \
		|| [[ "${custom6_show}" -eq 1 ]]; then
		printf '\n'
	fi
}
enter_to_continue() {
	printf '\n'
	read -r -e -p "Press [enter] to continue: " null
}
invalid_command() {
	printf '\n'
	error "Invalid command. See the help menu."
	enter_to_continue
}
print_separator() {
	printf '%s\n\n' "====================================================="
}
print_separator_commands() {
	printf '%s\n\n' "===================== COMMANDS ======================"
}
print_separator_device() {
	printf '%s\n\n' "==================== DEVICE MENU ===================="
}
print_separator_optical() {
	printf '%s\n\n' "=================== OPTICAL MEDIA ==================="
}
print_separator_removable() {
	printf '%s\n\n' "================== REMOVABLE MEDIA =================="
}
print_help() {
	clear_screen
	print_commands

	print_separator
	printf '%s' "${GREEN}==>${ALL_OFF} "
	printf '%s' "${BOLD}To mount the first device, enter ${ALL_OFF}"
	printf '%s' "${BLUE}1m${ALL_OFF}"
	printf '%s' "${BOLD}.${ALL_OFF}"
	printf '\n\n'
	printf '%s' "${GREEN}==>${ALL_OFF} "
	printf '%s' "${BOLD}To open the mountpath directory of the first${ALL_OFF}"
	printf '\n\n'
	printf '%s' "${BOLD}    device (mounting if required), enter "
	printf '%s' "${BLUE}1o${ALL_OFF}"
	printf '%s' "${BOLD}.${ALL_OFF}"
	printf '\n\n'
	printf '%s' "${GREEN}==>${ALL_OFF} "
	printf '%s' "${BOLD}To view a device sub-menu, just enter the number.${ALL_OFF}"
	printf '\n\n'
	printf '%s' "${GREEN}==>${ALL_OFF} "
	printf '%s' "${BLUE}a${ALL_OFF}"
	printf '%s' "${BOLD}, "
	printf '%s' "${BLUE}r${ALL_OFF}"
	printf '%s' "${BOLD}, "
	printf '%s'	"${BLUE}q${ALL_OFF} "
	printf '%s' "${BOLD}and "
	printf '%s' "${BLUE}?${ALL_OFF} "
	printf '%s' "${BOLD}do not require a number.${ALL_OFF}"
	printf '\n\n'
	print_separator

	enter_to_continue
}
print_help_sub() {
	clear_screen

	print_submenu_commands

	printf '\n'
	print_separator
	printf '%s' "${GREEN}==>${ALL_OFF} "
	printf '%s' "${BOLD}To perform a command, enter a character.${ALL_OFF}"
	printf '\n\n'
	printf '%s' "${GREEN}==>${ALL_OFF} "
	printf '%s' "${BOLD}For example, to mount this device, enter ${ALL_OFF}"
	printf '%s' "${BLUE}m${ALL_OFF}"
	printf '%s' "${BOLD}.${ALL_OFF}"
	printf '\n\n'
	print_separator

	enter_to_continue
}
# }}}

#-------------------------------------#
#            INTERNAL API             #
#-------------------------------------#
# {{{

# functions to retrieve information
info_blank() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*blank:" \
		| awk '{print $2}'
}
info_has_media() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*has media:" \
		| awk '{print $3}'
}
info_internal() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*system internal:" \
		| awk '{print $3}'
}
info_label() {
	local info_label="$($udisks --show-info ${1} \
		| grep -m 1 -w "^  label:" \
		| awk '{$1="";print substr($0, index($0,$2))}')"
	[[ -n "${info_label}" ]] && printf '%s\n' "${info_label}"
}
info_media() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*media:" \
		| awk '{print $2}'
}
info_model() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*model:" \
		| awk '{$1="";print substr($0, index($0,$2))}'
}
info_mounted() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*is mounted:" \
		| awk '{print $3}'
}
info_mountpath() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*mount paths:" \
		| awk '{$1="";$2="";print substr($0, index($0,$3))}'
}
info_type() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*type:" \
		| awk '{print $2}'
}
info_vendor() {
	$udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*vendor:" \
		| awk '{$1="";print substr($0, index($0,$2))}'
}
convert_size() {
	local -i old_size="${1}"
	local new_size=

	if [[ "${old_size}" -gt "21474836480" ]]; then
		new_size="$((${old_size}/1073741824)) GB"
	elif [[ "${old_size}" -gt "10485760" ]]; then
		new_size="$((${old_size}/1048576)) MB"
	elif [[ "${old_size}" -gt "10240" ]]; then
		new_size="$((${old_size}/1024)) kB"
	else
		new_size="${old_size} bytes"
	fi

	printf '%s\n' "${new_size}"
}
info_device_size() {
	local info_device_size=
	info_device_size="$($udisks --show-info ${1} \
		| grep -m 1 -w "^[[:space:]]*size:" \
		| awk '{print $2}')"
	if [[ -n "${info_device_size}" ]]; then
		info_device_size="$(convert_size "${info_device_size}")"
		printf '%s\n' "${info_device_size}"
	fi
}
info_partition_size() {
	local info_partition_size=
	info_partition_size="$($udisks --show-info ${1} \
		| grep -m 1 -w "  size:" \
		| awk '{print $2}')"
	if [[ -n "${info_partition_size}" ]]; then
		info_partition_size="$(convert_size "${info_partition_size}")"
		printf '%s\n' "${info_partition_size}"
	fi
}

# functions to perform udisks commands
check_device() {
	$udisks --enumerate-device-files | grep -ow ^${1}$ >/dev/null 2>&1
	if [[ $? -ne 0 ]]; then
		printf '\n'
		error "${1} is no longer available."
		enter_to_continue
		return 1
	fi
	return 0
}
action_eject() {
	local -i info_mounted=
	check_device "${1}" || return 1
	printf '\n'
	info_mounted="$(info_mounted "${1}")"
	if [[ "${info_mounted}" -eq 1 ]]; then
		msg "Unmounting and ejecting ${1} ..."
		printf '\n'
		$udisks --unmount ${1}
		info_mounted="$(info_mounted "${1}")"
		if [[ "${info_mounted}" -eq 1 ]]; then
			printf '\n'
			error "${1} could not be unmounted."
			printf '\n'
		fi
	else
		msg "Ejecting ${1} ..."
		printf '\n'
	fi
	$udisks --eject ${1}
	sleep 2
}
action_info() {
	check_device "${1}" || return 1
	$udisks --show-info "${1}" | less
}
action_mount() {
	local -i info_mounted=
	check_device "${1}" || return 1
	info_mounted="$(info_mounted ${1})"
	if [[ "${info_mounted}" -eq 1 ]]; then
		printf '\n'
		error "${1} is already mounted."
		enter_to_continue
		return 1
	fi
	
	printf '\n'
	msg "Mounting ${1} ..."
	printf '\n'
	$udisks ${mount_options} --mount ${1}
	info_mounted="$(info_mounted "${1}")"
	if [[ "${info_mounted}" -eq 1 ]]; then
		printf '\n'
		msg "${1} mounted successfully."
	else
		printf '\n'
		error "${1} could not be mounted."
	fi
	enter_to_continue
}
action_open() {
	local -i info_mounted=
	check_device "${1}" || return 1
	printf '\n'
	info_mounted="$(info_mounted "${1}")"
	if [[ "${info_mounted}" -eq 0 ]]; then
		msg "Mounting and opening ${1} ..."
		printf '\n'
		$udisks ${mount_options} --mount ${1}
		info_mounted="$(info_mounted "${1}")"
		if [[ "${info_mounted}" -eq 1 ]]; then
			printf '\n'
			msg "${1} mounted successfully."
		else
			printf '\n'
			error "${1} could not be mounted."
			enter_to_continue
			return 1
		fi
	fi
	info_mountpath="$(info_mountpath "${1}")"
	if [[ -z "${info_mountpath}" ]]; then
		printf '\n'
		error "No mountpath detected."
		enter_to_continue
		return 1
	fi
	printf '\n'
	msg "Opening ${1} ..."
	printf '\n'
	filemanager "${info_mountpath}"
	enter_to_continue
}
action_unmount() {
	local -i info_mounted=
	check_device "${1}" || return 1
	info_mounted="$(info_mounted "${1}")"
	if [[ "${info_mounted}" -eq 0 ]]; then
		printf '\n'
		error "${1} is already unmounted."
		enter_to_continue
		return 1
	fi

	printf '\n'
	msg "Unmounting ${1} ..."
	printf '\n'
	$udisks --unmount ${1}
	info_mounted="$(info_mounted "${1}")"
	if [[ "${info_mounted}" -eq 1 ]]; then
		printf '\n'
		error "${1} could not be unmounted."
		enter_to_continue
	else
		msg "${1} unmounted successfully."
		enter_to_continue
	fi
}
fancy_sort() {
	# this is a very hacky way to sort devices so that /dev/sdc11 wont come
	# before /dev/sdc2, which happens due to a shortcoming of the sort command

	# we wont tell bash that partition_number is a number, otherwise it
	# breaks when leading zeros are added
	local devname= devmajor= partition_number=
	local -i k=

	# first lets put a leading zero in front of single digits (sdc1 -> sdc01).
	# we are going to ignore /dev/mmcblk* devices... too complicated to sort.
	k=0
	for devname in ${removable[@]}; do
		if [[ "${devname}" =~ ^/dev/dm-[0-9]+ ]]; then
			devmajor="${devname%%[0-9]*}"
		elif [[ "${devname}" =~ ^/dev/fd[0-9]+ ]]; then
			devmajor="${devname%%[0-9]*}"
		elif [[ "${devname}" =~ ^/dev/sd[a-z][0-9]+ ]]; then
			devmajor="${devname%%[0-9]*}"
		else
			k=$((++k)); continue
		fi

		if [[ "${devname}" = "${devmajor}" ]]; then
			k=$((++k)); continue
		fi

		partition_number="${devname#${devmajor}}"
		removable[${k}]=${devmajor}$(printf '%02d' "${partition_number}")
		k=$((++k))
	done

	# now the device array can be sorted properly
	removable=( $(printf '%s\n' "${removable[@]}" | sort) )

	# now lets remove those leading zeros that we added
	k=0
	for devname in ${removable[@]}; do
		if [[ "${devname}" =~ ^/dev/dm-[0-9]+ ]]; then
			devmajor="${devname%%[0-9]*}"
		elif [[ "${devname}" =~ ^/dev/fd[0-9]+ ]]; then
			devmajor="${devname%%[0-9]*}"
		elif [[ "${devname}" =~ ^/dev/sd[a-z][0-9]+ ]]; then
			devmajor="${devname%%[0-9]*}"
		else
			k=$((++k)); continue
		fi

		if [[ "${devname}" = "${devmajor}" ]]; then
			k=$((++k)); continue
		fi

		partition_number="${devname#${devmajor}}"
		removable[${k}]=${devmajor}${partition_number#0}
		k=$((++k))
	done
}

# main functions
removable_devices() {
	local -a removable=( )

	j=0
	all_media=( )
	mounted_media=( )

	removable=( $($udisks --enumerate-device-files \
		| grep -ow ${removable_devices} | sort) )

	if [[ ${fancy_sort} -eq 1 ]] && [[ ${#removable[*]} -gt 1 ]]; then
		fancy_sort
	fi

	print_separator_removable

	for devname in ${removable[@]}; do
		local devmajor= partitions= info_label= menu_number=
		local -i internal= info_mounted=

		# check here to see if a device such as /dev/sdb has partitions. if there
		# are partitions, such as /dev/sdb1, then hide /dev/sdb from being shown.
		if [[ "${devname}" =~ ^/dev/mmcblk[0-9]+p*[0-9]* ]]; then
			devmajor="${devname%%p[0-9]*}"
			if [[ "${devname}" = "${devmajor}" ]]; then
				partitions="$($udisks --enumerate-device-files \
					| grep -ow -E ^${devname}p[0-9]+ -c)"
				if [[ "${partitions}" -gt 0 ]]; then
					continue
				fi
			fi
		else
			devmajor="${devname%%[0-9]*}"
			if [[ "${devname}" = "${devmajor}" ]]; then
				partitions="$($udisks --enumerate-device-files \
					| grep -ow -E ^${devname}[0-9]+ -c)"
				if [[ "${partitions}" -gt 0 ]]; then
					continue
				fi
			fi
		fi

		internal="$(info_internal "${devmajor}")"

		if [[ "${internal}" -eq 1 ]] && [[ "${show_internal}" -eq 0 ]]; then
			continue
		fi

		if [[ "${internal}" -eq 0 ]] || [[ "${show_internal}" -eq 1 ]]; then
			j=$((++j))

			info_label="$(info_label "${devname}")"
			# if no label is present, then use information about the device instead
			if [[ -z "${info_label}" ]]; then
				info_label="$(info_label "${devmajor}")"
				[[ -z "${info_label}" ]] && info_label="$(info_model "${devmajor}")"
				[[ -z "${info_label}" ]] && info_label="$(info_vendor "${devmajor}")"
				if [[ -z "${info_label}" ]]; then
					info_label="No label"
				else
					info_label="No label (${info_label})"
				fi
			fi

			if [[ ${j} -lt 10 ]]; then
				menu_number=" ${j}"
			else
				menu_number="${j}"
			fi

			info_mounted="$(info_mounted "${devname}")"
			if [[ "${info_mounted}" -eq 0 ]]; then
				if [[ "${show_removable_device_filename}" -eq 0 ]]; then
					printf '%s\n' "${BLUE}${menu_number})${ALL_OFF} ${info_label}"
				else
					printf '%s' "${BLUE}${menu_number})${ALL_OFF} ${devname#/dev/}: "
					printf '%s\n' "${info_label}"
				fi
			else
				if [[ "${show_removable_device_filename}" -eq 0 ]]; then
					printf '%s' "${BLUE}${menu_number})${ALL_OFF} ${info_label} "
					printf '%s\n' "${GREEN}[mounted]${ALL_OFF}"
				else
					printf '%s' "${BLUE}${menu_number})${ALL_OFF} ${devname#/dev/}: "
					printf '%s\n' "${info_label} ${GREEN}[mounted]${ALL_OFF}"
				fi
				mounted_media[${#mounted_media[*]}]=${devname}
			fi
			all_media[${#all_media[*]}]=${devname}
		fi
	done

	printf '\n'
}

optical_devices() {
	local -a optical=( )
	local menu_number=

	if [[ "${show_removable}" -eq 0 ]]; then
		j=0
		all_media=( )
		mounted_media=( )
	fi

	optical=( $($udisks --enumerate-device-files \
		| grep -ow ${optical_devices} | sort) )

	print_separator_optical

	for devname in ${optical[@]}; do
		local info_label=
		local -i blank= info_has_media= info_mounted=

		info_has_media="$(info_has_media "${devname}")"
		if [[ "${info_has_media}" -eq 0 ]]; then
			continue
		else
			j=$((++j))
			blank="$(info_blank "${devname}")"
			if [[ "${blank}" -eq 1 ]]; then
				info_label="Blank media"
			else
				info_label="$(info_label ${devname})"
				[[ -z "${info_label}" ]] && info_label="$(info_model "${devname}")"
				[[ -z "${info_label}" ]] && info_label="No label"
			fi

			if [[ ${j} -lt 10 ]]; then
				menu_number=" ${j}"
			else
				menu_number="${j}"
			fi

			info_mounted="$(info_mounted "${devname}")"
			if [[ "${info_mounted}" -eq 0 ]]; then
				if [[ "${show_optical_device_filename}" -eq 0 ]]; then
					printf '%s\n' "${BLUE}${menu_number})${ALL_OFF} ${info_label}"
				else
					printf '%s' "${BLUE}${menu_number})${ALL_OFF} ${devname#/dev/}: "
					printf '%s\n' "${info_label}"
				fi
			else
				if [[ "${show_optical_device_filename}" -eq 0 ]]; then
					printf '%s' "${BLUE}${menu_number})${ALL_OFF} ${info_label} "
					printf '%s\n' "${GREEN}[mounted]${ALL_OFF}"
				else
					printf '%s' "${BLUE}${menu_number})${ALL_OFF} ${devname#/dev/}: "
					printf '%s\n' "${info_label} ${GREEN}[mounted]${ALL_OFF}"
				fi
				mounted_media[${#mounted_media[*]}]=${devname}
			fi
			all_media[${#all_media[*]}]=${devname}
		fi
	done

	printf '\n'
}

sub_menu() {
	local devmajor= info_label= info_model= info_mountpath= info_vendor=
	local info_device_size= info_media= info_partition_size= info_type=
	local -i info_mounted= is_optical=

	check_device "${devname}" || return 1

	printf '%s\n' "${devname}" | grep -ow ${optical_devices} >/dev/null 2>&1
	if [[ $? -eq 0 ]]; then
		is_optical=1; devmajor="${devname}"
	else
		is_optical=0 ;devmajor="${devname%%[0-9]*}"
	fi

	clear_screen

	print_separator_device

	info_mounted="$(info_mounted "${devname}")"
	if [[ "${info_mounted}" -eq 1 ]]; then
		info_mountpath="$(info_mountpath "${devname}")"
	fi

	info_label="$(info_label "${devname}")"
	info_vendor="$(info_vendor "${devmajor}")"
	info_model="$(info_model "${devmajor}")"
	info_type="$(info_type "${devname}")"
	info_device_size="$(info_device_size "${devmajor}")"

	if [[ "${is_optical}" -eq 1 ]]; then
		info_media="$(info_media ${devname})"
	fi

	if [[ "${is_optical}" -eq 0 ]] && [[ "${devname}" != "${devmajor}" ]]; then
		info_partition_size="$(info_partition_size "${devname}")"
	fi

	printf '%s\n' "device           : ${devname}"
	printf '%s\n' "label            : ${info_label}"
	printf '%s' "mounted          : "
	if [[ "${info_mounted}" = "1" ]]; then
		printf '%s\n' "${GREEN}yes${ALL_OFF}"
		printf '%s\n\n' "mountpath        : ${info_mountpath}"
	else
		printf '%s\n\n' "${RED}no${ALL_OFF}"
	fi
	printf '%s\n' "vendor           : ${info_vendor}"
	printf '%s\n' "model            : ${info_model}"
	printf '%s\n' "type             : ${info_type}"
	[[ -n "${info_media}" ]] && printf '%s\n' "media            : ${info_media}"
	if [[ -n "${info_partition_size}" ]]; then
		printf '%s\n' "size (partition) : ${info_partition_size}"
	fi
	printf '%s\n' "size (device)    : ${info_device_size}"

	if [[ "${show_commands}" -eq 1 ]]; then
		printf '\n'
		print_submenu_commands
	fi

	printf '\n'
	print_separator
	printf '\n'

	read -r -e -p "Command: " action

	case "${action}" in
		"e")
			action_eject "${devname}"
			return 1;;
		"i")
			action_info "${devname}" || return 1
			return 0;;
		"m")
			action_mount "${devname}" || return 1
		 	return 0;;
		"o")
			action_open "${devname}" || return 1
			return 0;;
		"u")
			action_unmount "${devname}" || return 1
			return 0;;
		"b")
			return 1;;
		"r"|"")
			return 0;;
		"q")
			exit;;
		"?")
			print_help_sub
			return 0;;
		"1")
			if [[ "${custom1_show}" = "1" ]]; then
				printf '\n'
				msg "Running custom command '${custom1_desc}' ..."
				printf '\n'
				custom1_command "${devname}"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		"2")
			if [[ "${custom2_show}" = "1" ]]; then
				printf '\n'
				msg "Running custom command '${custom2_desc}' ..."
				printf '\n'
				custom2_command "${devname}"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		"3")
			if [[ "${custom3_show}" = "1" ]]; then
				printf '\n'
				msg "Running custom command '${custom3_desc}' ..."
				printf '\n'
				custom3_command "${devname}"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		"4")
			if [[ "${custom4_show}" = "1" ]]; then
				printf '\n'
				msg "Running custom command '${custom4_desc}' ..."
				printf '\n'
				custom4_command "${devname}"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		"5")
			if [[ "${custom5_show}" = "1" ]]; then
				printf '\n'
				msg "Running custom command '${custom5_desc}' ..."
				printf '\n'
				custom5_command "${devname}"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		"6")
			if [[ "${custom6_show}" = "1" ]]; then
				printf '\n'
				msg "Running custom command '${custom6_desc}' ..."
				printf '\n'
				custom6_command "${devname}"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		* )
			invalid_command
			return 0;;
	esac
}

select_action() {
	local devname=

	print_separator
	printf '\n'
	read -r -e -p "Command: " action

	if [[ ! "${action}" =~ ^[1-9][0-9]*[eimou]?$ ]]; then
		case "${action}" in
			"a")
				if [[ "${#mounted_media[@]}" -eq 0 ]]; then
					printf '\n'
					error "No devices mounted."
					enter_to_continue
					return 1
				fi
				printf '\n'
				read -r -e -p "Unmount all devices [y/N]?: " unmount
				[[ "${unmount}" != "y" ]] && return 0
				clear_screen
				for devname in ${mounted_media[@]}; do
					local -i info_mounted=
					check_device "${devname}" || continue
					printf '\n'
					info_mounted="$(info_mounted "${devname}")"
					if [[ "${info_mounted}" -eq 0 ]]; then
						printf '\n'
						error "${devname} is already unmounted."
						continue
					fi

					msg "Unmounting ${devname}..."
					printf '\n'
					$udisks --unmount ${devname}
					info_mounted="$(info_mounted "${devname}")"
					if [[ "${info_mounted}" -eq 1 ]]; then
						printf '\n'
						error "${devname} could not be unmounted."
						continue
					else
						msg "${devname} unmounted successfully."
					fi
				done
				enter_to_continue
				return 1;;
			"r"|"")
				return 0;;
			"q"|"b")
				exit 0;;
			"?")
				print_help
				return 0;;
			* )
				invalid_command
				return 1;;
		esac
	fi
	
	local number= letter= devname=

	number="$(($(printf '%s\n' "${action}" | grep -o -E ^[1-9][0-9]*)-1))"
	letter="$(printf '%s\n' "${action}" | grep -o -E [eimou]{1}$)"

	if [[ "${number}" -ge ${j} ]]; then
		invalid_command; return 1
	fi

	devname="${all_media[${number}]}"

	case "${letter}" in
		"e")
			action_eject "${devname}"
			return 0;;
		"i")
			action_info "${devname}"
			return 0;;
		"m")
			action_mount "${devname}"
			return 0;;
		"o")
			action_open "${devname}"
			return 0;;
		"u")
			action_unmount "${devname}"
			return 0;;
		* )
			while true; do
				sub_menu || break
			done
			return 0;;
	esac
}
# }}}

while true; do
	declare -i j=0 # tracks number assigned to each displayed device
	declare -a mounted_media=( )
	declare -a all_media=( )
	clear_screen
	[[ "${show_removable}" -eq 1 ]] && removable_devices
	[[ "${show_optical}" -eq 1 ]] && optical_devices
	[[ "${show_commands}" -eq 1 ]] && print_commands
	select_action
done

# vim: set ts=4 sw=4 noet foldmethod=marker :
